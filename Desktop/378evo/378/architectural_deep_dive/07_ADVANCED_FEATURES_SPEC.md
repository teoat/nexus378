# Advanced Features Specification: Meta-App, Help System & Live Dashboard

**Version:** 1.0
**Status:** Draft

## 1. Overview

### 1.1. What & Why

This document details the architecture for a suite of advanced, cross-cutting features designed to enhance the platform's user experience, utility, and intelligence.

*   **What:**
    1.  A **Live Operations Dashboard** for real-time system monitoring.
    2.  A **Proactive AI Help System** to provide contextual assistance.
    3.  A **Meta-Design Agent ("App-within-an-App")** that allows users to modify and redesign the application's structure and workflows locally.
*   **Why:** These features elevate the platform from a simple tool to a dynamic, intelligent, and self-improving environment. They provide users with unprecedented transparency, guidance, and control, fully integrating LangChain and LangGraph into every aspect of the user experience.

## 2. Feature 1: Live Operations Dashboard

### 2.1. Concept

A dedicated, real-time dashboard that provides users with a live overview of the entire system's status and their current session.

*   **UI/UX:** A configurable grid of widgets (similar to Grafana or the AWS console) that can be rearranged by the user.
*   **Data Sources:** The dashboard will be powered by real-time data pushed from the Node.js Gateway via WebSockets. The Gateway, in turn, aggregates this data from various sources (e.g., status updates from the Python service via RabbitMQ, database queries, its own API metrics).

### 2.2. Key Information Widgets

*   **Connected Services:** A widget showing the status (Online, Degraded, Offline) of the core backend services (Node Gateway, Python AI Service, PostgreSQL, Neo4j, RabbitMQ).
*   **Current Phase:** A visual indicator of the user's current stage in the forensic workflow (e.g., "Data Ingestion," "Reconciliation," "Reporting").
*   **Sectional Progress:** Detailed progress bars for long-running tasks (e.g., "Parsing file `statement.pdf`: 78% complete").
*   **Live Metrics:** Real-time charts displaying key session metrics (e.g., "Transactions Processed," "Fraud Alerts Generated," "Time Connected").
*   **Relevant Information Feed:** A feed of contextual insights generated by a dedicated LangGraph agent (e.g., "High-value transaction to a new vendor detected," "Pattern of round-number payments identified").

## 3. Feature 2: Proactive AI Help System

### 3.1. Concept

An intelligent, context-aware help system that provides guidance and best practices to the user in real-time.

*   **UI/UX:** A floating "help" icon that is always accessible. When clicked, it opens a chat-like interface. Additionally, small, non-intrusive "suggestion" pop-ups can appear near UI elements to offer contextual tips.
*   **Backend Engine:** This will be powered by a dedicated **`HelpAgent`** running in the Python AI Service. This agent will be a LangGraph-based RAG (Retrieval-Augmented Generation) agent.

### 3.2. How It Works

1.  **Contextual Triggers:** The frontend will periodically send context to the Node.js Gateway (e.g., `user is on page: 'reconciliation'`, `user is interacting with component: 'AdjudicationPanel'`).
2.  **Agent Invocation:** The Gateway forwards this context to the `HelpAgent`.
3.  **RAG Implementation:** The `HelpAgent` uses the context as a query to a vector database containing the application's documentation, best practices for forensic accounting, and tutorials.
4.  **Suggestion Generation:** The agent retrieves the most relevant information and uses an LLM to synthesize a helpful suggestion or answer.
5.  **Real-time Delivery:** The suggestion is sent back to the user's UI via the WebSocket connection.

## 4. Feature 3: Meta-Design Agent ("App-within-an-App")

### 4.1. Concept

A powerful, expert-level feature that allows authorized users to interact with a specialized AI agent to modify and redesign the application's folder structures, workflows, and components. This is a local-first design tool that generates plans and code modifications that can then be applied by a developer.

*   **UI/UX:** A dedicated "Design Studio" section of the application, featuring a chat interface, a file browser, and a code/diff viewer.
*   **Backend Engine:** This will be powered by a highly-specialized **`MetaDesignAgent`** in the Python AI Service. This agent will have access to a suite of powerful tools.

### 4.2. How It Works

1.  **User Prompt:** The user provides a high-level redesign goal in the chat interface (e.g., "Refactor the `DataIngestionModule` to separate PDF and CSV parsing into their own services," or "Create a new dashboard widget for visualizing fraud alerts by geographic location").
2.  **Agentic Workflow (LangGraph):** The `MetaDesignAgent` initiates a complex, multi-step workflow:
    *   **Analyze:** It uses its tools to read the current folder structure and the content of relevant files to understand the existing architecture.
    *   **Plan:** It formulates a step-by-step plan to achieve the user's goal, which it presents to the user for approval.
    *   **Generate:** Once the plan is approved, it generates the new code, configuration files, or modifications. It does **not** apply them directly.
    *   **Present:** It presents the proposed changes to the user in a diff view for final review.
3.  **MCP Integration:** The `MetaDesignAgent` will heavily utilize the **Model Context Protocol (MCP)** to interact with the local file system, read file contents, and potentially even run local linters or tests to validate its proposed changes. This keeps the agent's actions grounded in the actual state of the local codebase.
4.  **Output:** The final output is a set of proposed file changes (diffs) or new files that the user can then choose to apply to their local development environment.

### 4.3. Gap Analysis & Recommendations

*   **Gap:** The biggest challenge with the Meta-Design Agent is security and safety. An agent with file system access is extremely powerful.
*   **Recommendation:**
    1.  **Strict Sandboxing:** The MCP server providing file system access **must** be strictly sandboxed to the project directory.
    2.  **Read-Only by Default:** The agent should primarily have read-only access. Write operations should require explicit, multi-step user confirmation.
    3.  **Human-in-the-Loop:** No file modification should ever happen automatically. The agent's role is to *propose* changes, and the user's role is to *approve and apply* them. This maintains a critical human-in-the-loop safety mechanism.