import pika
import json
import os
from pymongo import MongoClient
from agents.reconciliation_agent import (
    create_reconciliation_agent,
    ReconciliationState,
)
from agents.dashboard_agent import create_dashboard_agent


def main():
    # Connect to RabbitMQ
    rabbitmq_url = os.environ.get(
        "RABBITMQ_URL", "amqp://user:password@rabbitmq:5672"
    )
    connection = pika.BlockingConnection(pika.URLParameters(rabbitmq_url))
    channel = connection.channel()

    # Declare queues
    channel.queue_declare(queue="discrepancy-analysis")
    channel.queue_declare(queue="reconciliation.start")

    # Connect to MongoDB
    mongo_uri = os.environ.get("MONGODB_URI")
    if not mongo_uri:
        raise Exception("MONGODB_URI not set")
    mongo_client = MongoClient(mongo_uri)
    db = mongo_client.get_default_database()

    reconciliation_agent = create_reconciliation_agent()

    def callback(ch, method, properties, body):
        queue_name = method.routing_key
        try:
            print(
                f" [x] Received message from queue '{queue_name}': {body.decode()}"
            )
            data = json.loads(body)

            if queue_name == "discrepancy-analysis":
                handle_discrepancy_analysis(data, db)
            elif queue_name == "reconciliation.start":
                handle_reconciliation_start(data, reconciliation_agent)
            else:
                print(
                    f" [!] Warning: Received message from unknown queue '{queue_name}'. Ignoring."
                )

            ch.basic_ack(delivery_tag=method.delivery_tag)

        except json.JSONDecodeError:
            print(" [!] Error: Could not decode message body. Rejecting.")
            ch.basic_reject(delivery_tag=method.delivery_tag, requeue=False)
        except Exception as e:
            print(
                f" [!] An unexpected error occurred: {e}. Rejecting message."
            )
            ch.basic_reject(delivery_tag=method.delivery_tag, requeue=False)

    def handle_discrepancy_analysis(data, db_conn):
        case_id = data.get("caseId")
        if not case_id:
            raise ValueError("Message missing caseId")

        print(f" [*] Processing discrepancy for case: {case_id}")
        dummy_discrepancy = {
            "caseId": case_id,
            "type": "unclassified_transaction",
            "description": "Dummy discrepancy generated by AI service.",
            "status": "open",
        }
        db_conn.discrepancies.insert_one(dummy_discrepancy)
        print(f" [x] Created dummy discrepancy for case {case_id}")

    def handle_reconciliation_start(data, agent):
        print(f"[*] Starting reconciliation for job: {data.get('jobId')}")
        initial_state: ReconciliationState = {
            "job_id": data.get("jobId"),
            "case_id": data.get("caseId"),
            "file_id": data.get("fileId"),
            "mapping_id": data.get("mappingId"),
            "scope": data.get("scope"),
            "scope_value": data.get("scopeValue"),
            "transactions": [],
            "results": [],
        }
        # The `stream` method executes the graph and yields the state at each step.
        for state in agent.stream(initial_state):
            print(f"[*] Agent state: {state}")
        print(f"[*] Finished reconciliation for job: {data.get('jobId')}")

    channel.basic_consume(
        queue="discrepancy-analysis", on_message_callback=callback
    )
    channel.basic_consume(
        queue="reconciliation.start", on_message_callback=callback
    )

    # Add a consumer for the dashboard agent
    dashboard_agent = create_dashboard_agent()
    channel.queue_declare(queue="dashboard.insights")

    def dashboard_callback(ch, method, properties, body):
        insights = dashboard_agent.invoke({})
        channel.basic_publish(
            exchange="",
            routing_key="dashboard.insights.results",
            body=json.dumps(insights),
        )

    channel.basic_consume(
        queue="dashboard.insights", on_message_callback=dashboard_callback
    )

    print(" [*] Waiting for messages. To exit press CTRL+C")
    channel.start_consuming()


if __name__ == "__main__":
    main()
